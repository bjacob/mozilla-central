<html>
<script>
  var cycleIndex = -1;
  var cycle;
  var refgraph;
  var controller;
  function start() {
    controller = new RefgraphController;
  }
  function snapshot() {
    window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
        .getInterface(Components.interfaces.nsIDOMWindowUtils)
        .cycleCollect();
    controller = new RefgraphController;
    controller.snapshotToFile("/tmp/refgraph.log");
    var newrefgraph = controller.loadFromFile("/tmp/refgraph.log");
    if (!newrefgraph) {
      alert("snapshot failed");
      return;
    }
    refgraph = newrefgraph;
    document.getElementById("cyclecount").innerHTML = refgraph.cycleCount;
    cycle = null;
    cycleIndex = -1;
    cyclesSummary();
  }
  function loadfromfile() {
    var filename = document.getElementById("loadfileinput").value;
    var newrefgraph = controller.loadFromFile(filename);
    if (!newrefgraph) {
      alert("loading file failed");
      return;
    }
    refgraph = newrefgraph;
    document.getElementById("cyclecount").innerHTML = refgraph.cycleCount;
    cycle = null;
    cycleIndex = -1;
    cyclesSummary();
  }
  function snapshottofile() {
    var filename = document.getElementById("savefileinput").value;
    controller.snapshotToFile(filename);
  }
  function indent(level) {
    var r = "";
    for (var i = 0; i < level; i++) {
      r += "    ";
    }
    return r;
  }
  function dumpVertex(vertex, level, root_address, itbcc) {
    var ind = indent(level);
    var output = "";
    output += ind + "type name: " + vertex.typeName + "\n";
    output += ind + "address: 0x" + vertex.address.toString(16) + "\n";
    output += ind + "size: " + vertex.size + " bytes\n";
    if (vertex.cycleIndex != vertex.ALONE_IN_CYCLE) {
      output += ind + "belongs to Cycle " + vertex.cycleIndex + "\n";
    }
    if (level >= 2 &&
        root_address == vertex.address &&
        itbcc == false)
    {
      output += ind + "*** CYCLE NOT TRAVERSED BY THE CC! ***\n";
    }
    if (level <= 2) {
      var edgeCount = vertex.edgeCount;
      for (var i = 0; i < edgeCount; i++) {
        var edge = vertex.edge(i);
        var isTraversedByCC = edge.isTraversedByCC;
        if (edge.refName) {
          output += ind + "reference name: " + edge.refName + "\n";
        }
        if (edge.refTypeName) {
          output += ind + "reference type name: " + edge.refTypeName + "\n";
        }
        output += ind + (isTraversedByCC ? "traversed" : "NON-traversed") + " by the CC\n";
        output += dumpVertex(edge.target, level + 1, root_address, itbcc && isTraversedByCC);
      }
    }
    return output;
  }
  function typeSearch() {
    var typeSearchInput = document.getElementById("typesearchinput").value;
    var searchResults = refgraph.typeSearch(typeSearchInput);
    var resultText = "";
    for (var i = 0; i < searchResults.length; i++) {
      if (searchResults[i].typeName) {
        resultText += searchResults[i].objectCount + " " + searchResults[i].typeName + "\n";
      } else {
        resultText += searchResults[i].objectCount + " <No type information>\n";
      }
    }
    if (searchResults.length >= 1) {
      var typeName = searchResults[0].typeName;
      resultText += "\n\nFirst result: " + typeName + "\n";
      var vertexCount = 0;
      for(var vertex = refgraph.findVertex(typeName, null);
          vertex != null && vertexCount < 10;
          vertex = refgraph.findVertex(typeName, vertex))
      {
        resultText += "\n\nVertex:\n\n";
        resultText += dumpVertex(vertex, 0, vertex.address, true);
        vertexCount++;
      }
    }
    document.getElementById("results").textContent = resultText;
  }
  function addressSearch() {
    var addressSearchInput = document.getElementById("addresssearchinput").value;
    var address = parseInt(addressSearchInput, 16);
    var vertex = refgraph.findVertex(address);
    var resultText = "";
    if (vertex) {
      resultText += dumpVertex(vertex, 0, vertex.address, true);
    }
    document.getElementById("results").textContent = resultText;
  }
  function cycleNext() {
    if (refgraph.cycleCount == 0) {
      return;
    }
    var nonTraversedByCCOnly = document.getElementById("nonTraversedByCCOnly").checked;
    var skipdupes = document.getElementById("skipdupes").checked;
    while (true) {
      cycleIndex = Math.min(cycleIndex+1, refgraph.cycleCount - 1);
      var oldcycle = cycle;
      cycle = refgraph.cycle(cycleIndex);
      if (cycleIndex == refgraph.cycleCount - 1) {
        break;
      }
      if (skipdupes &&
          cycle && oldcycle &&
          cycle.name == oldcycle.name &&
          cycle.vertexCount == oldcycle.vertexCount &&
          cycle.isTraversedByCC == oldcycle.isTraversedByCC)
      {
        continue;
      }

      if (!nonTraversedByCCOnly) {
        break;
      }
      if (!cycle.isTraversedByCC) {
        break;
      }
    }
    printCycle();
  }
  function cyclePrev() {
    if (refgraph.cycleCount == 0) {
      return;
    }
    var nonTraversedByCCOnly = document.getElementById("nonTraversedByCCOnly").checked;
    var skipdupes = document.getElementById("skipdupes").checked;
    while (true) {
      cycleIndex = Math.max(cycleIndex-1, 0);
      var oldcycle = cycle;
      cycle = refgraph.cycle(cycleIndex);
      if (cycleIndex == 0) {
        break;
      }
      if (skipdupes &&
          cycle &&
          cycle.name == oldcycle.name &&
          cycle.vertexCount == oldcycle.vertexCount &&
          cycle.isTraversedByCC == oldcycle.isTraversedByCC)
      {
        continue;
      }
      if (!nonTraversedByCCOnly) {
        break;
      }
      if (!cycle.isTraversedByCC) {
        break;
      }
    }
    printCycle();
  }
  function cycleSearch() {
    var cycleSearchInput = document.getElementById("cyclesearchinput").value;
    var result = parseInt(cycleSearchInput, 10);
    if (result) {
      cycleIndex = result;
    }
    printCycle();
  }
  function printCycle() {
    var resultText = "";
    var vertexCount = cycle.vertexCount;
    resultText = "Cycle " + cycleIndex + " has " + vertexCount + " vertices.\n\n";
    if (!cycle.isTraversedByCC) {
      resultText += "Is NOT traversed by the CC!\n\n";
      var isReferencedByOutside = false;
      for (var i = 0; i < vertexCount; i++) {
        var vertex = cycle.vertex(i);
        var backEdgeCount = vertex.backEdgeCount;
        for (var e = 0; e < backEdgeCount; e++) {
          var back = vertex.backEdge(e);
          if (back.cycleIndex != cycleIndex) {
            var t = back.typeName;
            isReferencedByOutside = true;
            backRefCount++;
          }
        }
      }
      var isWeakReferencedByOutside = false;
      for (var i = 0; i < vertexCount; i++) {
        var vertex = cycle.vertex(i);
        var backWeakEdgeCount = vertex.backWeakEdgeCount;
        for (var e = 0; e < backWeakEdgeCount; e++) {
          var back = vertex.backWeakEdge(e);
          if (back.cycleIndex != cycleIndex) {
            var t = back.typeName;
            isWeakReferencedByOutside = true;
            backRefCount++;
          }
        }
      }
      if (!isReferencedByOutside && !isWeakReferencedByOutside) {
        resultText += "This cycle is NOT referenced at all by outside heap blocks!\n";
        resultText += "Almost certainly leaked!\n";
      } else if (!isReferencedByOutside) {
        resultText += "This cycle is NOT strong-referenced by outside!\n";
      }
    }
    resultText += "Types involved: " + cycle.name + "\n\n";
    var reachableFromOutside = false;
    for (var i = 0; i < vertexCount; i++) {
      var vertex = cycle.vertex(i);
      resultText += "type name: " + vertex.typeName + "\n";
      resultText += "address: 0x" + vertex.address.toString(16) + "\n";
      resultText += "size: " + vertex.size + " bytes\n";
      if (vertex.cycleIndex != vertex.ALONE_IN_CYCLE) {
        resultText += "cycleIndex: " + vertex.cycleIndex + "\n";
      }
      resultText += "Cycle edges:\n";
      for (var j = 0; j < vertex.edgeCount; j++) {
        var edge = vertex.edge(j);
        var target = edge.target;
        if (target.address == vertex.address) {
          continue;
        }
        if (target.cycleIndex == cycleIndex) {
          resultText += "    " + edge.refTypeName + " " + edge.refName + " to " + target.typeName + " at 0x" + target.address.toString(16) + "\n";
          if (!edge.isTraversedByCC) {
            resultText += "        NOT TRAVERSED BY CC\n";
          }
        }
      }
      var backEdgeCount = vertex.backEdgeCount;
      var backWeakEdgeCount = vertex.backWeakEdgeCount;
      var backRefCount = 0;
      var backWeakRefCount = 0;
      for (var e = 0; e < backEdgeCount; e++) {
        var back = vertex.backEdge(e);
        if (back.cycleIndex != cycleIndex) {
          var t = back.typeName;
          resultText += "referenced by " + (t ? t : "<unknown>") + " at 0x" + back.address.toString(16) + "\n";
          backRefCount++;
        }
      }
      resultText += "backRefCount: " + backRefCount + "\n";
      for (var e = 0; e < backWeakEdgeCount; e++) {
        var back = vertex.backWeakEdge(e);
        if (back.cycleIndex != cycleIndex) {
          var t = back.typeName;
          resultText += "weak-referenced by " + (t ? t : "<unknown>") + " at 0x" + back.address.toString(16) + "\n";
          backWeakRefCount++;
        }
      }
      resultText += "backWeakRefCount: " + backWeakRefCount + "\n\n\n";
    }
    document.getElementById("results").textContent = resultText;
  }
  function cyclesSummary() {
    var resultText = "";
    function report(count, name, vertexCount, isTraversedByCC) {
      if (count) {
          resultText += "" + count
                      + "  [" + vertexCount
                      + " vertices" + (isTraversedByCC ? "" : ", NON-traversed by CC")
                      + "]     " + name  + "\n";
      }
    }
    var cycleCount = refgraph.cycleCount;
    var lastName, lastVertexCount, lastIsTraversedByCC;
    var count = 0;
    for (var i = 0; i < cycleCount; i++) {
      var cycle = refgraph.cycle(i);
      var name = cycle.name;
      var vertexCount = cycle.vertexCount;
      var isTraversedByCC = cycle.isTraversedByCC;
      if (name != lastName || vertexCount != lastVertexCount || isTraversedByCC != lastIsTraversedByCC) {
        if (count) {
          report(count, lastName, lastVertexCount, lastIsTraversedByCC);
        }
        lastName = name;
        lastVertexCount = vertexCount;
        lastIsTraversedByCC = isTraversedByCC;
        count = 1;
      } else {
        count++;
      }
    }
    report(count, lastName, lastVertexCount, lastIsTraversedByCC);
    document.getElementById("results").textContent = resultText;
  }
  
</script>
<body onload="start()">
  <input type="button" value="Take a snapshot of this browser" onClick="snapshot()"/><br/>
  Load snapshot from file: <input type="text" id="loadfileinput"/>
  <input type="button" value="Load" onClick="loadfromfile()"/>
  <br/>
  Take a snapshot and save to: <input type="text" id="savefileinput"/>
  <input type="button" value="Save" onClick="snapshottofile()"/>
  <br/>
  Type search: <input type="text" id="typesearchinput"/>
  <input type="button" value="Search" onClick="typeSearch()"/>
  <br/>
  Address search: <input type="text" id="addresssearchinput"/>
  <input type="button" value="Search" onClick="addressSearch()"/>
  <br/>
  <input type="button" value="Cycles summary" onClick="cyclesSummary()"/>
  <br/>
  Cycle search
  <input type="text" id="cyclesearchinput"/> out of <div id="cyclecount"></div>
  <input type="button" value="Search" onClick="cycleSearch()"/>

  <input type="button" value="<" onclick="cyclePrev()"></input>
  <input type="button" value=">" onclick="cycleNext()"></input>
  <br/>
  <input type="checkbox" id="nonTraversedByCCOnly" checked="true"></input> Only show cycles that are not traversed by the CC
  <br/>
  <input type="checkbox" id="skipdupes" checked="true"></input> Skip duplicate cycles
  <br/>
  <pre id="results"/>
</body>
</html>
