<html>
<script>
  var sccIndex = 0;
  var refgraph;
  function start() {
    window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
        .getInterface(Components.interfaces.nsIDOMWindowUtils)
        .cycleCollect();
    refgraph = new Refgraph();
    document.getElementById("scccount").innerHTML = refgraph.sccCount;
  }
  function indent(level) {
    var r = "";
    for (var i = 0; i < level; i++) {
      r += "    ";
    }
    return r;
  }
  function dumpVertex(vertex, level, root_address, itbcc) {
    var ind = indent(level);
    var output = "";
    output += ind + "type name: " + vertex.typeName + "\n";
    output += ind + "address: 0x" + vertex.address.toString(16) + "\n";
    output += ind + "size: " + vertex.size + " bytes\n";
    if (vertex.sccIndex != refgraph.ALONE_IN_SCC) {
      output += ind + "belongs to SCC " + vertex.sccIndex + "\n";
    }
    if (level >= 2 &&
        root_address == vertex.address &&
        itbcc == false)
    {
      output += ind + "*** CYCLE NOT TRAVERSED BY THE CC! ***\n";
    }
    if (level <= 2) {
      var edgeCount = vertex.edgeCount;
      for (var i = 0; i < edgeCount; i++) {
        var edge = vertex.edge(i);
        if (edge.isStrong) {
          var isTraversedByCC = edge.isTraversedByCC;
          output += ind + (isTraversedByCC ? "traversed" : "NON-traversed") + " " + edge.refTypeName + " edge\n";
          output += dumpVertex(edge.target, level + 1, root_address, itbcc && isTraversedByCC);
        }
      }
    }
    return output;
  }
  function typeSearch() {
    var typeSearchInput = document.getElementById("typesearchinput").value;
    var searchResults = refgraph.typeSearch(typeSearchInput);
    var resultText = "";
    for (var i = 0; i < searchResults.length; i++) {
      if (searchResults[i].typeName) {
        resultText += searchResults[i].objectCount + " " + searchResults[i].typeName + "\n";
      } else {
        resultText += searchResults[i].objectCount + " <No type information>\n";
      }
    }
    if (searchResults.length >= 1) {
      var typeName = searchResults[0].typeName;
      resultText += "\n\nFirst result: " + typeName + "\n";
      var vertexCount = 0;
      for(var vertex = refgraph.findVertex(typeName, null);
          vertex != null && vertexCount < 10;
          vertex = refgraph.findVertex(typeName, vertex))
      {
        resultText += "\n\nVertex:\n\n";
        resultText += dumpVertex(vertex, 0, vertex.address, true);
        vertexCount++;
      }
    }
    document.getElementById("results").textContent = resultText;
  }
  function addressSearch() {
    var addressSearchInput = document.getElementById("addresssearchinput").value;
    var address = parseInt(addressSearchInput, 16);
    var vertex = refgraph.findVertex(address);
    var resultText = "";
    if (vertex) {
      resultText += dumpVertex(vertex, 0, vertex.address, true);
    }
    document.getElementById("results").textContent = resultText;
  }
  function sscNext() {
    sccIndex = Math.min(sccIndex+1, refgraph.sccCount - 1);
    printScc();
  }
  function sscPrev() {
    sccIndex = Math.max(sccIndex-1,0);
    printScc();
  }
  function sccSearch() {
    var sccSearchInput = document.getElementById("sccsearchinput").value;
    sccIndex = parseInt(sccSearchInput, 10);
    printScc();
  }
  function printScc() {
    var scc = refgraph.scc(sccIndex);
    var resultText = "";
    resultText = "SCC " + sccIndex + " has " + scc.length + " vertices.\n\n";
    for (var i = 0; i < scc.length; i++) {
      var vertex = scc[i];
      resultText += "type name: " + vertex.typeName + "\n";
      resultText += "address: 0x" + vertex.address.toString(16) + "\n";
      resultText += "size: " + vertex.size + " bytes\n";
      resultText += "SCC edges:\n";
      for (var j = 0; j < vertex.edgeCount; j++) {
        var edge = vertex.edge(j);
        if (!edge.isStrong) {
          continue;
        }
        var target = edge.target;
        if (target.address == vertex.address) {
          continue;
        }
        if (target.sccIndex == sccIndex) {
          resultText += "    " + edge.refTypeName + " to " + target.typeName + " at " + target.address.toString(16) + "\n";
          if (!edge.isTraversedByCC) {
            resultText += "        NOT TRAVERSED BY CC\n";
          }
        }
      }
    }
    document.getElementById("results").textContent = resultText;
  }
  
</script>
<body onload="start()">
  Type search: <input type="text" id="typesearchinput"/>
  <input type="button" value="Search" onClick="typeSearch()"/>
  <br/>
  Address search: <input type="text" id="addresssearchinput"/>
  <input type="button" value="Search" onClick="addressSearch()"/>
  <br/>
  SCC search
  <input type="text" id="sccsearchinput"/>
  out of <div id="scccount"></div>
  <input type="button" value="Search" onClick="sccSearch()"/>

  <input type="button" value="<" onclick="sscPrev()"></intput><div id="scccount2"></div> <input type="button" value=">" onclick="sscNext()"></intput>
  <br/>
  <pre id="results"/>
</body>
</html>
